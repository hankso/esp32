import { type, html, notEmpty, gzipCompress } from '@/utils'

import axios from 'axios'
import { basename, resolve } from 'path-browserify'

export async function getSchema(name = '', opt = {}) {
    return axios.get(resolve('/', `${name ? name + '.' : ''}schema.json`), opt)
}

const api = axios.create({
    baseURL: '/api/',
    timeout: 5000,
})

async function merge(opt1, opt2, instance = api) {
    return instance(axios.mergeConfig(opt1, opt2))
}

export async function isAPmode(opt = {}) {
    return merge(opt, { url: 'apmode' })
}

export async function getConfig(opt = {}) {
    return merge(opt, { url: 'config' })
}

export async function setConfig(cfg, opt = {}) {
    return merge(opt, {
        url: 'config',
        method: 'POST',
        data: `json=${JSON.stringify(cfg)}`,
    })
}

export async function getMedia(opt = {}) {
    return Promise.all([
        merge(opt, {
            url: 'media',
            params: { video: '' },
            validateStatus: false,
        }),
        merge(opt, {
            url: 'media',
            params: { audio: '' },
            validateStatus: false,
        }),
    ])
}

export async function setCamera(cfg, opt = {}) {
    return merge(opt, {
        url: 'media',
        method: 'POST',
        data: `video=${JSON.stringify(cfg)}`,
    })
}

export async function listDir(path = '', opt = {}) {
    return merge(opt, {
        url: 'edit',
        params: { path, list: '' },
    }).then(resp => {
        resp.data.forEach(node => {
            node.name = node.name.replace(new RegExp(`^${path}`), '')
        })
        return resp
    })
}

export async function readFile(path, download = false, opt = {}) {
    return merge(opt, {
        url: 'edit',
        responseType: 'text', // raw file: do NOT parse to json
        params: download ? { path, download: '' } : { path },
    })
}

export async function createPath(path, isdir = true, opt = {}) {
    return merge(opt, {
        url: 'edit',
        method: 'PUT',
        params: { path, type: isdir ? 'dir' : 'file' },
    })
}

export async function deletePath(path, isdir = false, opt = {}) {
    return merge(opt, {
        url: 'edit',
        method: 'DELETE',
        params: { path, type: isdir ? 'dir' : 'file' },
    })
}

async function toFormData(data, name = 'data') {
    let tmp = data
    let dtype = type(data)
    let fname = name
    switch (dtype) {
        case 'blob':
            break
        case 'file':
            fname = basename(data.name)
            break
        case 'string':
            fname = basename(name)
            if (fname.endsWith('.gz')) {
                let bytes = await gzipCompress(tmp)
                tmp = new Blob([bytes], { type: 'application/gzip' })
            } else {
                tmp = new Blob([tmp], { type: 'text/plain' })
            }
            break
        case 'uint8array':
        case 'arraybuffer':
            fname = basename(name)
            tmp = new Blob([tmp], { type: 'application/octet-stream' })
            break
        case 'object':
            tmp = new Blob([JSON.stringify(tmp)], { type: 'application/json' })
            break
        case 'formdata':
            return Promise.resolve(data)
        default:
            return Promise.reject({ message: `Invalid type ${dtype}` })
    }
    data = new FormData()
    data.append(name, tmp, fname)
    return Promise.resolve(data)
}

export async function uploadFile(name, file, opt = {}) {
    return toFormData(file, name).then(data =>
        merge(opt, {
            url: 'edit',
            method: 'POST',
            params: { overwrite: '' },
            timeout: 0,
            data,
        })
    )
}

export async function updateOTA(firmware, opt = {}) {
    return toFormData(firmware, 'update').then(data =>
        merge(opt, {
            url: 'update',
            method: 'POST',
            timeout: 0,
            data,
        })
    )
}

export async function execCommand(cmd, opt = {}) {
    let ctype = type(cmd)
    switch (ctype) {
        case 'string':
            break
        case 'array':
            cmd = cmd.join(' ')
            break
        case 'object':
            cmd = Object.entries(cmd)
                .filter(kv => kv[1])
                .map(kv => kv[0])
                .join(' ')
            break
        default:
            return Promise.reject({ message: `Invalid type ${ctype}` })
    }
    return merge(opt, {
        url: 'exec',
        method: 'POST',
        data: `cmd=${cmd.trim().replace('helpe', 'help')}`,
        timeout: 30000,
    })
}

function parseCommand(str) {
    // Command help text generated by argtable3 seems like this:
    //      <name> [<hints> ...]
    //      <desc>
    //          [<args desc>]
    //          [...]
    let lines = (str + '').trim().split('\n')
    if (lines.length < 2) return
    let cmd = {
        key: lines[0].split(' ')[0].replace('help', 'helpe'),
        group: 'esp32',
        usage: lines[0].trim(),
        description: lines[1].trim(),
    }
    if (lines.length > 3)
        cmd.example = [{ cmd: html(lines.slice(2).join('\n')) }]
    return cmd
}

export async function getCommands(opt = {}) {
    return execCommand('help', opt).then(resp => {
        resp.data = resp.data.split('\n\n').map(parseCommand).filter(notEmpty)
        return resp
    })
}
